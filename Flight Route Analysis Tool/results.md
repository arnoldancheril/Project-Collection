## OpenFlights Dataset

### Written Report:

In this final project of CS 225, we set out to use the Airports and Routes datasets from openflights.org to create an algorithm that can be used by everyone. We wanted to see how the data on openflights.org can be put to good use and provide us with results that we can use in the real world. We used the Breadth-First Search (BFS) Algorithm, Djikstra’s Algorithm, and the Page Rank algorithm to build a program that would help us calculate the shortest path between any two given airports.


We started this project by downloading the airports and routes data sets from openflights.org. The files we downloaded had .dat extensions and hence had to be processed before we could effectively use them to create a graph. We used Python to clean and process these files and convert them into files that we could use so that we could create a graph with the data points and hence use the graph in the algorithms we develop. Each airport in the ‘airports’ data set stores the Airport ID, Airport Name, Airport Code, City, Country, Latitude, Longitude, and other information. A lot of the data that was available to us was not necessary for us to implement the algorithms we had in mind. In hindsight, it might have made it easier for us to discard the unnecessary fields during the creation of the .csv files. However, we were able to obtain the necessary fields without too much difficulty. To build the graph, we created airport objects for each of the airports in the airports.dat file. Each airport object has attributes of the Airport ID, 3-letter IATA code, 4-letter ICAO code, latitude, and longitude. Using these attributes, we created a graph with the airports as the nodes, routes as the edges, and the distances between airports as the weights.

We implemented the Breadth-First Search (BFS) algorithm for our traversal of the graph. We take a starting node (airport) and graph as the input and print out the BFS traversal from that node. The BFS algorithm traverses the graph structure to explore all the nodes along each branch. The algorithm starts at the input node and explores all of the connections to the node before moving on to the next level. We utilize a queue to store the nodes and explore them based on the order of the queue. The test suite for the BFS algorithm tests both for connected and disconnected graphs and also tests to make sure that a proper traversal is done on a graph with one node.

We also implemented Dijkstra’s algorithm to find the shortest path between two input airports. The algorithm maps each node to the node that last updated its path length. We use the distances between airports as the weights for this algorithm. The expected output of this algorithm is a list of nodes that are to be followed from the source to the destination as the shortest path between the two airports. We initially thought that the output given by the algorithm was wrong. There were multiple instances where there was a straight flight from the source to the destination. However, the algorithm gave a path that had an intermediate node. We realized that this was because the path length with an intermediate node was actually less than the path length of the direct flight between the two nodes. The tests for Dijkstra's algorithm check to ensure the algorithm works properly for a direct flight and on a flight with multiple stops.

The last algorithm that we implemented is the Page Rank algorithm. We used the Page Rank algorithm to rank the airports according to their importance. This algorithm finds the number of connections at each node and hence determines the importance of each airport. We take the graph as the input to this algorithm and output a list of the highest-ranked airports. We first calculate the importance of each node when equal. We then take the importance and multiply it by the number of connections that node has and the damping factor which is on average 0.85 for the page rank algorithm. The 85% damping factor is based on the assumption that 15% of the people stay on the same node and do not move on to the next node. The Page Rank is finally calculated by adding (1 - DampingFactor)/n to the value from the previous step in order to account for any factors lost due to the damping factor. We then ask for the number of airports to be ranked and print the same. The test on the Page Rank algorithm prints the top 100 ranked airports of the OpenFlights dataset.

The leading question that we proposed was: Utilizing the OpenFlights dataset, what is the shortest path between two airports? We were able to answer this question utilizing the algorithms outlined above, in particular, Dijkstra’s algorithm proved a direct answer to that question, as it took in two airports/nodes and was able to output the shortest path. We were able to discover that by utilizing both algorithms, covered and uncovered in our CS 225 course we are able to make a working program that provides useful information using a variety of data structures and algorithms.

The overall final project was a very big learning experience for all the team members. We faced issues of miscommunication, lack of participation, lack of commitment, and a few other issues but through all those issues, we have managed to deliver this project by the deadline. 


### Resources:
* https://en.wikipedia.org/wiki/Breadth-first_search
* https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm
* https://en.wikipedia.org/wiki/PageRank

